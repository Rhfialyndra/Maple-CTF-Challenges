# ECLCG

* Category: Crypto
* Score: /500
* Solves: 

## Description

LCG is fun, ECDSA is fun too, so why not combine them together?

## Overview

It signs 16 messages with ECDSA using secp256k1, with nonces $k_i$ generated by a LCG with unknown parameters $(a,b,p)$. The target is to recover the private key from the signatures.

## Solution

> Warning: I do not fully understand why my solver works, so the explanation here is most likely wrong.

This writeup will roughly explain how [solve2.py](./solution/solve2.py) work, which is modified from my first working solver [solve.py](./solution/solve.py). But what they actually do is the same, just with different implementation.

First, take any two message and signature pairs $(z_1, r_1, s_1)$ and $(z_2, r_2, s_2)$, we can derive the following equation from ECDSA signing process:

$$
s_1^{-1} z_1 - s_2^{-1} z_2 + (s_1^{-1} r_1 - s_2^{-1} r_2) d \equiv k_1 - k_2 \pmod{q}
$$

where $d$ is the private key, $k_i$ are the nonces, and $q$ is the order of the curve.

So from the given $n=16$ signatures, define these $n-1$ dimensional vectors:

$$
\begin{aligned}
(v_1)_i &= s_i^{-1} z_i - s_{i+1}^{-1} z_{i+1} \\
(v_2)_i &= s_i^{-1} r_i - s_{i+1}^{-1} r_{i+1} \\
(\Delta k)_i &= k_i - k_{i+1}
\end{aligned}
$$

It follows that:

$$
v_1 + v_2 d \equiv \Delta k \pmod{q}
$$

Then apply orthogonal lattice to $v_1, v_2$, we would recover a $n-1$ dimension basis $O$, which satisfy $O \mu = \Delta k$ over integers with a small vector $\mu$.

> $O$ is the `ortho2.T` in the solver.

From the properties of LCG, we can see that:

$$
a \cdot ((\Delta k)_1, \cdots, (\Delta k)_{n-1}) - ((\Delta k)_2, \cdots, (\Delta k)_{n}) \equiv 0 \pmod{p}
$$

which is

$$
a \cdot \mathop{\text{Slice}}(\Delta k, 0, n-1) - \mathop{\text{Slice}}(\Delta k, 1, n) \equiv a \cdot \mathop{\text{Slice}(O \mu, 0, n-1)} - \mathop{\text{Slice}(O \mu, 1, n)} \equiv 0 \pmod{p}

$$

where $\mathop{\text{Slice}}(\cdot)$ denotes Python's slicing operation (so zero indexed).

And it can be further simplified to:

$$
\left( a \cdot \mathop{\text{Slice}(O, 0, n-1)} - \mathop{\text{Slice}(O, 1, n)} \right) \mu \equiv 0 \pmod{p}
$$

Since $\mu$ is small, we can reasonably expect there would be a short vector in $a \cdot \mathop{\text{Slice}(O, 0, n-1)} - \mathop{\text{Slice}(O, 1, n)}$ modulo $p$ orthogonal to $\mu$ in $\mathbb{Z}$.

Here we assume that $p$ is known. We can see that reducing $\mathop{\text{Slice}(O, 0, n-1)}$ and $\mathop{\text{Slice}(O, 1, n)}$ modulo $p$ simultaneously, and it would result in $2 \times (n-4)$ short vectors orthogonal to $\mu$. So computing the kernel of the matrix formed by these vectors over $\mathbb{Z}$ would give $\mu$ (up to sign), which allows us to recover $\Delta k$, and hence $d$.

While this explaination sounds reasonable (to me), I find that replacing the $p$ used in the last step with any reasonably large prime $p' \neq q$ also works, and this is why I think my explanation above is wrong.

> @genni first blooded this challenge, and he said his solution is based on Stern's algorithm, which only require one LLL to solve the challenge. I have no idea how it works, but I think it is worth mentioning and I might try to understand it later.
